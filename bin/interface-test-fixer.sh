#!/bin/bash
# interface-test-fixer.sh - Fixes interface references in test files
# This script analyzes and fixes interface references in test files

# Configuration
PROJECT_ROOT="/home/george/sites/gl-color-palette-generator"
TEST_ROOT="$PROJECT_ROOT/tests"
INTERFACES_ROOT="$PROJECT_ROOT/includes/interfaces"
RESULTS_FILE="$PROJECT_ROOT/interface_fixes_results.txt"
BUGS_FILE="$PROJECT_ROOT/interface_issues.md"
FIX_SCRIPT="$PROJECT_ROOT/fix_interface_references.sh"
TEST_FILES="$PROJECT_ROOT/test_files_to_analyze.txt"
LAST_PROCESSED_LINE="$PROJECT_ROOT/last_processed_interface_line.txt"
BATCH_SIZE=10
CURRENT_BATCH=1

# Initialize or create files if they don't exist
touch "$BUGS_FILE"
touch "$LAST_PROCESSED_LINE"

# Initialize results file with header
cat > "$RESULTS_FILE" << EOL
# Interface Test Analysis Results
#
# This file contains the results of analyzing interface references in test files.
# Each line represents a test file and its interface references.
# Generated by bin/interface-test-fixer.sh on $(date)
#
## Field Descriptions
#
# 1. STATUS: MATCH (correct reference), MISMATCH (incorrect reference), or NOMATCH (no matching interface found)
# 2. TEST_FILE: Path to the test file
# 3. INTERFACE_REF: The interface reference found in the test file
# 4. SUGGESTED_INTERFACE: For MISMATCHes, the suggested correct interface name
# 5. INTERFACE_FILENAME: The expected filename for the interface
# 6. CONFIDENCE: For MISMATCHes, the confidence level (percentage) of the suggestion
# 7. INTERFACE_FILE_PATH: Path to the expected interface file
# 8. FILE_EXISTS: Whether the expected interface file exists (Yes/No)
# 9. TEST_CLASS_COUNT: Number of test classes in the file
# 10. BATCH: The processing batch number
# 11. FIX_STATUS: Whether the fix has been applied (Pending/Applied/Skipped)
#
## Results
#
STATUS|TEST_FILE|INTERFACE_REF|SUGGESTED_INTERFACE|INTERFACE_FILENAME|CONFIDENCE|INTERFACE_FILE_PATH|FILE_EXISTS|TEST_CLASS_COUNT|BATCH|FIX_STATUS
------|---------|-------------|-------------------|------------------|----------|-------------------|-----------|----------------|-----|----------
EOL

# Add header to the bugs file if it doesn't exist
if [ ! -s "$BUGS_FILE" ]; then
  cat << 'EOF' > "$BUGS_FILE"
# Interface Issues

This file documents issues found with interfaces and their references in test files.

## Naming Convention Issues

| Interface File | Interface Name | Test File | Test Reference | Issue | Batch |
|---------------|---------------|-----------|---------------|-------|-------|
EOF
fi

# Function to generate the fix script header
generate_fix_script_header() {
  # Only create a new script for the first batch
  if [ "$CURRENT_BATCH" -eq 1 ] || [ ! -f "$FIX_SCRIPT" ]; then
    cat << 'EOF' > "$FIX_SCRIPT"
#!/bin/bash
# fix_interface_references.sh - Generated script to fix interface references in test files
# This script was automatically generated by bin/interface-test-fixer.sh

# Safety check to prevent running in the wrong directory
if [ "$(basename "$(pwd)")" != "gl-color-palette-generator" ]; then
  echo "ERROR: This script must be run from the project root directory"
  echo "Current directory: $(pwd)"
  echo "Please cd to the project root directory and try again"
  exit 1
fi

EOF
  else
    # For subsequent batches, add a batch separator
    echo -e "\n# ===== BATCH $CURRENT_BATCH ===== #\n" >> "$FIX_SCRIPT"
  fi
}

# Function to build the interface map
build_interface_map() {
  local map_file="$PROJECT_ROOT/interface_map.txt"
  > "$map_file"  # Clear the file

  echo "Building interface map..."

  # Find all interface files and extract their names
  for interface_file in "$INTERFACES_ROOT"/*.php; do
    if [ -f "$interface_file" ]; then
      # Extract the interface name from the file - look for the actual interface declaration, not comments
      # This looks for 'interface Name' and captures just the name part
      interface_name=$(grep -n "^[[:space:]]*interface [A-Za-z_]*" "$interface_file" | tail -1 | sed -E 's/^[0-9]*:[[:space:]]*interface ([A-Za-z_]*).*/\1/')

      if [ -n "$interface_name" ]; then
        # Get the filename without path and extension
        filename=$(basename "$interface_file" .php)

        # Remove the 'interface-' prefix to get the key
        key=$(echo "$filename" | sed 's/^interface-//')

        # Add to the map file as key:value
        echo "$key:$interface_name" >> "$map_file"
        echo "  Mapped $key -> $interface_name"
      fi
    fi
  done

  echo "Interface map built with $(wc -l < "$map_file") entries"
}

# Function to find all test files and save to a file
find_test_files() {
  find "$TEST_ROOT" -name "test-*.php" -type f | sort > "$TEST_FILES"
  echo "Found $(wc -l < "$TEST_FILES") test files."
}

# Function to get the next batch of files to process
get_next_batch() {
  local last_line=0
  if [ -f "$LAST_PROCESSED_LINE" ]; then
    last_line=$(cat "$LAST_PROCESSED_LINE")
  fi

  local total_lines=$(wc -l < "$TEST_FILES")
  local start_line=$((last_line + 1))
  local end_line=$((start_line + BATCH_SIZE - 1))

  if [ $start_line -gt $total_lines ]; then
    echo "All files have been processed."
    return 1
  fi

  if [ $end_line -gt $total_lines ]; then
    end_line=$total_lines
  fi

  # Calculate absolute batch number based on file position
  CURRENT_BATCH=$(( (start_line - 1) / BATCH_SIZE + 1 ))

  echo "Processing batch $CURRENT_BATCH: files $start_line to $end_line (of $total_lines total)"
  sed -n "${start_line},${end_line}p" "$TEST_FILES" > "$PROJECT_ROOT/current_batch.txt"
  echo $end_line > "$LAST_PROCESSED_LINE"

  return 0
}

# Build the interface map once at the beginning
build_interface_map

# Function to process a batch of test files
process_batch() {
  local batch_file="$PROJECT_ROOT/current_batch.txt"
  local total=$(wc -l < "$batch_file")
  local count=0

  # Generate a new fix script for this batch
  generate_fix_script_header

  # Process each test file in the batch
  echo "Processing $total test files in batch $CURRENT_BATCH..."
  while IFS= read -r test_file; do
    ((count++))
    test_basename=$(basename "$test_file")
    echo "[$count/$total] Analyzing $test_basename..."

    interface_refs=$(grep -o "use GL_Color_Palette_Generator\\\\Interfaces\\\\[A-Za-z_]*;" "$test_file" | sed 's/.*\\\([A-Za-z_]*\);/\1/')

    if [ -z "$interface_refs" ]; then
      echo "  No interface references found, skipping"
      rel_test_file=$(echo "$test_file" | sed "s|$PROJECT_ROOT/||")
      echo "INFO|$rel_test_file|NO_INTERFACES||||||||$CURRENT_BATCH|N/A" >> "$RESULTS_FILE"
      continue
    fi

    # Process each interface reference
    while IFS= read -r ref; do
      # Try different transformations of the reference name to find a match
      found_match=false
      actual_interface=""
      matched_key=""
      match_confidence=0

      # Expected interface name based on naming conventions
      expected_key=$(echo "$ref" | sed 's/_/-/g' | tr '[:upper:]' '[:lower:]')
      expected_interface_file="$INTERFACES_ROOT/interface-$expected_key.php"

      # Check if expected interface file exists
      if [ -f "$expected_interface_file" ]; then
        expected_file_exists="Yes"
      else
        expected_file_exists="No"
      fi

      # 1. Try direct match with the map keys
      if grep -q "^$expected_key:" "$PROJECT_ROOT/interface_map.txt"; then
        actual_interface=$(grep "^$expected_key:" "$PROJECT_ROOT/interface_map.txt" | cut -d':' -f2)
        matched_key="$expected_key"
        found_match=true
        match_confidence=100
      fi

      # 2. Try a more precise fuzzy match if direct match fails
      if [ "$found_match" = false ]; then
        highest_confidence=0
        best_match_key=""
        best_match_interface=""

        while IFS=':' read -r key interface_value; do
          # Convert reference to lowercase with hyphens for comparison
          ref_compare=$(echo "$ref" | sed 's/_/-/g' | tr '[:upper:]' '[:lower:]')

          # Calculate match confidence based on string similarity
          # Exact match = 100%
          if [ "$key" = "$ref_compare" ]; then
            confidence=100
          # If key is a substring of reference or vice versa, calculate percentage of overlap
          elif [[ "$key" == *"$ref_compare"* ]]; then
            # Key contains reference - higher confidence
            confidence=$((${#ref_compare} * 100 / ${#key}))
          elif [[ "$ref_compare" == *"$key"* ]]; then
            # Reference contains key - lower confidence
            confidence=$((${#key} * 80 / ${#ref_compare}))
          # Special case for common patterns
          elif [[ "$key" == *"-interface"* && "$ref_compare" != *"-interface"* ]]; then
            # Reference might be missing the interface suffix
            key_without_interface=$(echo "$key" | sed 's/-interface//')
            if [[ "$key_without_interface" == "$ref_compare"* || "$ref_compare" == *"$key_without_interface"* ]]; then
              confidence=85
            else
              confidence=0
            fi
          else
            confidence=0
          fi

          # Keep track of the best match
          if [ "$confidence" -gt "$highest_confidence" ]; then
            highest_confidence=$confidence
            best_match_key=$key
            best_match_interface="$interface_value"
          fi
        done < "$PROJECT_ROOT/interface_map.txt"

        # Use the best match if confidence is above threshold
        if [ "$highest_confidence" -gt 50 ]; then
          found_match=true
          actual_interface="$best_match_interface"
          matched_key="$best_match_key"
          match_confidence=$highest_confidence
        fi
      fi

      # Process the match or report not found
      if [ "$found_match" = true ]; then
        # If the reference doesn't match the actual interface name
        if [ "$ref" != "$actual_interface" ]; then
          echo "  Mismatch: Test references '$ref' but actual interface is '$actual_interface' (matched via $matched_key, confidence: $match_confidence%)"
          echo "  - Test file: $test_file"
          echo "  - Expected interface file: $expected_interface_file (exists: $expected_file_exists)"

          # Add to results file with batch number
          rel_test_file=$(echo "$test_file" | sed "s|$PROJECT_ROOT/||")
          echo "MISMATCH|$rel_test_file|$ref|$actual_interface|$matched_key|$match_confidence|$expected_interface_file|$expected_file_exists|$test_class_count|$CURRENT_BATCH|Pending" >> "$RESULTS_FILE"

          # Generate fix commands only for high-confidence matches
          if [ "$match_confidence" -eq 100 ]; then
            certainty="CERTAIN"
          else
            certainty="REQUIRES REVIEW"
          fi

          # Generate a clear, concise description of what's being changed
          # Get the relative path from the project root
          relative_path=$(echo "$test_file" | sed "s|$PROJECT_ROOT/||")
          echo "# FILE: $relative_path" >> "$FIX_SCRIPT"
          echo "# CHANGE: Interface '$ref' should be '$actual_interface' ($match_confidence% confidence)" >> "$FIX_SCRIPT"

          # Check for naming consistency issues (for future refactoring)
          if [[ "$actual_interface" == *"_Interface"* ]]; then
            # This interface follows the _Interface suffix pattern
            # Check if there are other interfaces referenced in the same file that don't follow this pattern
            other_refs=$(grep -o "GL_Color_Palette_Generator\\\\Interfaces\\\\[A-Za-z0-9_]*" "$test_file" | sed 's/.*\\\\//' | grep -v "^$ref$" | grep -v "_Interface$")
            if [ -n "$other_refs" ]; then
              echo "# NAMING CONSISTENCY NOTE: This file also references interfaces that could be renamed for consistency:" >> "$FIX_SCRIPT"
              echo "$other_refs" | while read -r other_ref; do
                echo "#   - $other_ref → ${other_ref}_Interface" >> "$FIX_SCRIPT"
              done
            fi
          elif [[ "$actual_interface" != *"_Interface"* ]]; then
            # This interface doesn't follow the _Interface suffix pattern
            # Check if there are other interfaces referenced in the same file that do follow this pattern
            other_refs=$(grep -o "GL_Color_Palette_Generator\\\\Interfaces\\\\[A-Za-z0-9_]*" "$test_file" | sed 's/.*\\\\//' | grep -v "^$ref$" | grep "_Interface$")
            if [ -n "$other_refs" ]; then
              echo "# NAMING CONSISTENCY NOTE: This file also references interfaces with _Interface suffix:" >> "$FIX_SCRIPT"
              echo "$other_refs" | while read -r other_ref; do
                base_name=$(echo "$other_ref" | sed 's/_Interface$//')
                echo "#   - $other_ref → $base_name (or add _Interface to all)" >> "$FIX_SCRIPT"
              done
            fi
          fi

          # Add information about the expected interface file
          if [ "$expected_file_exists" = "No" ]; then
            echo "# NOTE: Expected interface file '$expected_interface_file' does not exist (check for similar filenames)" >> "$FIX_SCRIPT"

            # Try to find the implementation class that might need this interface
            implementation_class=$(echo "$ref" | sed 's/_Interface$//')
            potential_class_files=$(find "$PROJECT_ROOT/includes" -name "class-*-${implementation_class,,}.php" -o -name "class-${implementation_class,,}.php" -o -name "class-${implementation_class,,}-*.php" 2>/dev/null)

            if [ -n "$potential_class_files" ]; then
              echo "# POTENTIAL IMPLEMENTATION CLASSES that might need this interface:" >> "$FIX_SCRIPT"
              echo "$potential_class_files" | while read -r class_file; do
                echo "#   - $class_file" >> "$FIX_SCRIPT"
              done
            else
              echo "# No potential implementation classes found for this interface (might be missing or using a different name)" >> "$FIX_SCRIPT"
            fi
          fi

          # Check if test file might contain a class specifically for this interface
          # First check if there are multiple classes in the file
          class_count=$(grep -c "class [A-Za-z0-9_]*" "$test_file")

          # For interfaces, the test class name should be Test_Name (without _Interface suffix)
          interface_base_name=$(echo "$actual_interface" | sed 's/_Interface$//')
          expected_test_name="Test_${interface_base_name}"

          if [ "$class_count" -gt 1 ]; then
            # Multiple classes - check if any match our expected name
            if grep -q "class $expected_test_name" "$test_file"; then
              # Found a matching class - no renaming needed
              echo "# File contains multiple test classes (${class_count}) with a correctly named class for this interface" >> "$FIX_SCRIPT"
            else
              # Check if there's a class that might need renaming for this specific interface
              # This is complex and might need manual review
              echo "# File contains multiple test classes - manual review recommended" >> "$FIX_SCRIPT"
              echo "# Expected class name for this interface would be '$expected_test_name'" >> "$FIX_SCRIPT"
            fi
          else
            # Single class - check if it needs renaming
            test_class_name=$(grep -o "class [A-Za-z0-9_]*" "$test_file" | head -1 | sed 's/class //')

            if [ "$test_class_name" != "$expected_test_name" ]; then
              # Only suggest renaming if it's not a special case like 'for'
              if [ "$test_class_name" != "$expected_test_name" ] && [ "$test_class_name" != "for" ]; then
                echo "# TEST CLASS NAMING: Current test class '$test_class_name' could be renamed to '$expected_test_name'" >> "$FIX_SCRIPT"
                echo "# This would better align with your naming conventions" >> "$FIX_SCRIPT"
              elif [ "$test_class_name" = "for" ]; then
                echo "# WARNING: Test class name 'for' detected - this is likely an error in parsing the file" >> "$FIX_SCRIPT"
              fi
            fi
          fi
          echo "#" >> "$FIX_SCRIPT"

          # Add commented commands for complete confidence matches
          if [ "$match_confidence" -eq 100 ]; then
            echo "sed -i 's/use GL_Color_Palette_Generator\\\\\\\\Interfaces\\\\\\\\$ref;/use GL_Color_Palette_Generator\\\\\\\\Interfaces\\\\\\\\$actual_interface;/g' \"$test_file\"" >> "$FIX_SCRIPT"
            echo "sed -i 's/\\($ref\\)::/\\($actual_interface\\)::/g' \"$test_file\"" >> "$FIX_SCRIPT"
            echo "sed -i 's/@covers \\\\GL_Color_Palette_Generator\\\\\\\\Interfaces\\\\\\\\$ref/@covers \\\\GL_Color_Palette_Generator\\\\\\\\Interfaces\\\\\\\\$actual_interface/g' \"$test_file\"" >> "$FIX_SCRIPT"
          fi
          echo "" >> "$FIX_SCRIPT"

          # Add to bugs file with batch number
          interface_filename="interface-${matched_key}.php"
          echo "| $interface_filename | $actual_interface | $test_basename | $ref | Naming mismatch (confidence: $match_confidence% - $certainty) | $CURRENT_BATCH |" >> "$BUGS_FILE"
        else
          echo "  Match: Test correctly references '$ref'"
          # Get relative path from project root
        rel_test_file=$(echo "$test_file" | sed "s|$PROJECT_ROOT/||")
        echo "MATCH|$rel_test_file|$ref||||$expected_interface_file|$expected_file_exists|$test_class_count|$CURRENT_BATCH|N/A" >> "$RESULTS_FILE"
        fi
      else
        echo "  No match found for interface reference '$ref'"
        echo "  - Test file: $test_file"
        echo "  - Expected interface file: $expected_interface_file (exists: $expected_file_exists)"
        echo "  - Recommendation: Check if this interface should exist or if the reference is incorrect"

        # Get relative path from project root
        rel_test_file=$(echo "$test_file" | sed "s|$PROJECT_ROOT/||")
        echo "NOMATCH|$rel_test_file|$ref|||$expected_interface_file|$expected_file_exists|$test_class_count|$CURRENT_BATCH|N/A" >> "$RESULTS_FILE"
        echo "| Unknown | Unknown | $test_basename | $ref | No matching interface found (expected: $expected_key, file exists: $expected_file_exists) | $CURRENT_BATCH |" >> "$BUGS_FILE"
      fi
    done <<< "$interface_refs"
  done < "$batch_file"

  # Add progress markers to the fix script
  echo -e "\necho \"Processed batch $CURRENT_BATCH\"\n" >> "$FIX_SCRIPT"

  echo "Batch $CURRENT_BATCH analysis complete!"
  echo "Results for batch $CURRENT_BATCH saved to $RESULTS_FILE"
  echo "Fix script for batch $CURRENT_BATCH generated at $FIX_SCRIPT"

  # Increment batch counter
  CURRENT_BATCH=$((CURRENT_BATCH + 1))
}

# Function to show statistics
show_statistics() {
  # Count test files and decisions
  total_tests=$(wc -l < "$TEST_FILES" 2>/dev/null || echo "0")

  # Initialize counters
  matches=0
  mismatches=0
  no_matches=0
  no_refs=0

  # Count different types of results if the file exists
  if [ -f "$RESULTS_FILE" ]; then
    matches=$(grep -c "^MATCH:" "$RESULTS_FILE")
    mismatches=$(grep -c "^MISMATCH:" "$RESULTS_FILE")
    no_matches=$(grep -c "^NOMATCH:" "$RESULTS_FILE")
    no_refs=$(grep -c "No interface references found" "$RESULTS_FILE")
  fi

  # Calculate total processed
  processed=$((matches + mismatches + no_matches + no_refs))

  # Display statistics
  echo "Statistics:"
  echo "Total test files: $total_tests"
  echo "Processed files: $processed"
  echo "Files with correct interface references: $matches"
  echo "Files with mismatched interface references: $mismatches"
  echo "Files with no matching interfaces: $no_matches"
  echo "Files with no interface references: $no_refs"

  # Count confidence levels for mismatches
  if [ "$mismatches" -gt 0 ] && [ -f "$RESULTS_FILE" ]; then
    high_conf=$(grep "^MISMATCH:" "$RESULTS_FILE" | grep -c ":100:")
    med_conf=$(grep "^MISMATCH:" "$RESULTS_FILE" | grep -E ":[7-9][0-9]:" | grep -v ":100:" | wc -l)
    low_conf=$(grep "^MISMATCH:" "$RESULTS_FILE" | grep -E ":[5-6][0-9]:" | wc -l)

    echo ""
    echo "Mismatch confidence levels:"
    echo "High confidence (100%): $high_conf"
    echo "Medium confidence (70-99%): $med_conf"
    echo "Low confidence (50-69%): $low_conf"
  fi
}

# Function to show the main menu
main_menu() {
  while true; do
    echo ""
    echo "Interface Test Fixer"
    echo "1. Find all test files"
    echo "2. Process next batch of test files"
    echo "3. View results for current batch (press q to quit display)"
    echo "4. View bugs/issues found (press q to quit display)"
    echo "5. View fix script for current batch (press q to quit display)"
    echo "6. Show statistics"
    echo "7. Reset progress (start over)"
    echo "8. Exit"
    read -p "Select an option: " option

    case $option in
      1)
        find_test_files
        ;;
      2)
        if get_next_batch; then
          process_batch
        fi
        ;;
      3)
        if [ -f "$RESULTS_FILE" ]; then
          echo -e "\nResults for batch $((CURRENT_BATCH - 1)):"
          grep -A 20 "=== BATCH $((CURRENT_BATCH - 1))" "$RESULTS_FILE" | less
        else
          echo "No results file found."
        fi
        ;;
      4)
        if [ -f "$BUGS_FILE" ]; then
          echo -e "\nBugs/issues found:"
          less "$BUGS_FILE"
        else
          echo "No bugs file found."
        fi
        ;;
      5)
        if [ -f "$FIX_SCRIPT" ]; then
          echo -e "\nFix script for batch $((CURRENT_BATCH - 1)):"
          less "$FIX_SCRIPT"
        else
          echo "No fix script found."
        fi
        ;;
      6)
        show_statistics
        ;;
      7)
        echo "Resetting progress..."
        rm -f "$LAST_PROCESSED_LINE"
        > "$RESULTS_FILE"
        > "$BUGS_FILE"
        > "$FIX_SCRIPT"
        CURRENT_BATCH=1
        echo "Progress reset. Ready to start over."
        ;;
      8)
        echo "Exiting..."
        exit 0
        ;;
      *)
        echo "Invalid option. Please try again."
        ;;
    esac
  done
}

# Check if we're in the right directory
if [ "$(basename "$(pwd)")" != "gl-color-palette-generator" ]; then
  echo "ERROR: This script must be run from the project root directory"
  echo "Current directory: $(pwd)"
  echo "Please cd to the project root directory and try again"
  exit 1
fi

# Main execution
echo "Interface Test Fixer"
echo "This script will analyze test files for interface references and generate fixes."

# If no command line arguments, show the menu
if [ $# -eq 0 ]; then
  main_menu
else
  # Process command line arguments
  case "$1" in
    "--find")
      find_test_files
      ;;
    "--process")
      if get_next_batch; then
        process_batch
      fi
      ;;
    "--reset")
      echo "Resetting progress..."
      rm -f "$LAST_PROCESSED_LINE"
      > "$RESULTS_FILE"
      > "$BUGS_FILE"
      > "$FIX_SCRIPT"
      CURRENT_BATCH=1
      echo "Progress reset. Ready to start over."
      ;;
    "--auto")
      # Process all batches automatically
      find_test_files
      while get_next_batch; do
        process_batch
      done
      echo "All batches processed."
      ;;
    *)
      echo "Unknown command: $1"
      echo "Valid commands: --find, --process, --reset, --auto"
      exit 1
      ;;
  esac
fi
